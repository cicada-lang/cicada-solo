---
section: Datatype
title: Proving Theorems About Nat
---

Before going to next `datatype`, let's prove some theorems about `Nat`,
to show off the power of dependent types!

Let's prove the commutative property of addition for natural number.

It says,

> When doing addition for natural number,
> the order of the numbers can be changed without changing the answer.
>
> x + y = y + x

We import `Nat` and `add` from previous chapter first.

``` cicada
import { Nat, add } from "./01-nat.md"
```

Then we can express the following theorems by a type in our programming language,

> For all `x` and `y` in `Nat`, `add(x, y)` is equal to `add(y, x)`.

``` cicada
let add_commute_t: Type = (
  x: Nat, y: Nat,
) -> Equal(Nat, add(x, y), add(y, x))
```

# Mathematical Induction in Action

## Understanding the problem

TODO

## Devising a plan

TODO

## Carrying out the plan

TODO

``` cicada
import {
  equal_map,
  equal_swap,
  equal_compose,
} from "../equality/01-equal-utilities.md"
```

``` cicada
function add_zero_commute(
  x: Nat
): Equal(Nat, add(Nat.zero, x), add(x, Nat.zero)) {
  return induction (x) {
    (x) => Equal(Nat, add(Nat.zero, x), add(x, Nat.zero))
    case zero => refl
    case add1(prev, almost) => equal_map(almost.prev, Nat.add1)
  }
}
```

``` cicada
function add_add1_commute(
  x: Nat, y: Nat,
): Equal(Nat, add(x, Nat.add1(y)), Nat.add1(add(x, y))) {
  return induction (x) {
    (x) => Equal(Nat, add(x, Nat.add1(y)), Nat.add1(add(x, y)))
    case zero => refl
    case add1(prev, almost) => equal_map(almost.prev, Nat.add1)
  }
}
```

``` cicada
function add_commute(
  x: Nat, y: Nat,
): Equal(Nat, add(x, y), add(y, x)) {
  return induction (x) {
    (x) => Equal(Nat, add(x, y), add(y, x))
    // Base case
    case zero => add_zero_commute(y)
    // Induction step
    case add1(prev, almost) =>
      equal_compose(
        equal_map(almost.prev, Nat.add1),
        equal_swap(add_add1_commute(y, prev)),
      )
  }
}
```

## Looking back

We import some example `Nat` to test our proof.

``` cicada
import { two, three } from "./01-nat.md"

add_commute(two, three)
add_commute(three, two)
```
