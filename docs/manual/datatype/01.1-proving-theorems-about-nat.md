---
section: Datatype
title: Proving Theorems About Nat
---

Before going to the next `datatype` -- `List`, let's prove some theorems about `Nat`,
to show off the power of dependent types!

How about the **commutative property of addition** for natural number?

It says,

> When doing addition for natural number,
> the order of the numbers can be changed without changing the answer.
>
> x + y = y + x

We import `Nat` and `add` from previous chapter first.

``` cicada
import { Nat, add } from "./01-nat.md"
```

Then we can express the following theorems by a type in our programming language,

> For all `x` and `y` in `Nat`, `add(x, y)` is equal to `add(y, x)`.

``` cicada
(x: Nat, y: Nat) -> Equal(Nat, add(x, y), add(y, x))
```

# Let's prove it!

To prove the theorem,
let's follow Pólya's advices about problem solving steps.

- Thanks, George Pólya (1887 – 1985),
  for your great teachings,
  and your lovely book "How to Solve It" (1945).

## 1. Understanding the problem

**What is the unknown?**

We need to prove a theorem in our programming language,
the theorem is expressed by a type, and to prove it
is to construct an element of that type.

> A theorem expressed by a type, is like a puzzle --
> a game between us and the type checker.
>
> If we can construct an element of that type, we win!

And we see the type is a `Pi`,
so its element will probably be a function.

The result type of the `Pi` is constructed by `Equal`,
we might need to use `Equal`'s constructors in our proof.

**What are the data?**

We have the definition of `Nat`, we already know a lot about it.

And we have the definition of `add`,
which tall us how the computation of addition is performed,
both in the case of `zero` and in the case of `add1`.

We also know something about the built-in type `Equal`,
but maybe we need to learn more about it.

## 2. Devising a plan

How should we prove the commutative property of addition in English mathematical prose?

Here is my plan, I want to review the proof in prose,
and try to translate it to our programming language.

> For all `x` and `y` in `Nat`, `add(x, y)` is equal to `add(y, x)`.

**Proof by mathematical induction over `x`.**

- **Base case, suppose `x` is `zero`.**

  It is obvious that

  ``` cicada inactive
  add(zero, y) = add(y, zero)
  ```

  because both sides are equal to `y`.

- **Inductive step, suppose `x` is `add1(prev)`.**

  We have inductive hypothesis

  ``` cicada inactive
  add(prev, y) = add(y, prev)
  ```

  We need to prove

  ``` cicada inactive
  add(add1(prev), y) = add(y, add1(prev))
  ```

  If for the left hand side we have

  ``` cicada inactive
  add(add1(prev), y) = add1(add(prev, y)) // Lemma 1
  ```

  and for the right hand side we have

  ``` cicada inactive
  add(y, add1(prev)) = add1(add(y, prev)) // Lemma 2
  ```

  Then we can use inductive hypothesis to prove

  ``` cicada inactive
  add1(add(prev, y)) = add1(add(y, prev))
  ```

  by applying `add1` to inductive hypothesis

  ``` cicada inactive
       add(prev, y)  =      add(y, prev)
  add1(add(prev, y)) = add1(add(y, prev))
  ```

  Now we turn to prove Lemma 1 and Lemma 2.

  - **Proof of Lemma 1.**

    ``` cicada inactive
    add(add1(prev), y) = add1(add(prev, y))
    ```

    by the definition of `add` in the case of `add1`

    ``` cicada inactive
    add(add1(prev), y) =
    add1(almost.prev) =
    add1(add(prev, y))
    ```

  - **Proof of Lemma 2, by mathematical induction over `y`.**

    ``` cicada inactive
    add(y, add1(prev)) = add1(add(y, prev))
    ```

    - **Base case, suppose `y` is `zero`.**

      It is obvious that

      ``` cicada inactive
      add(zero, add1(prev)) = add1(add(zero, prev))
      ```

      because both sides are equal to `add1(prev)`.

    - **Inductive step, suppose `y` is `add1(y_prev)`.**

      We have inductive hypothesis

      ``` cicada inactive
      add(y_prev, add1(prev)) = add1(add(y_prev, prev))
      ```

      We need to prove

      ``` cicada inactive
      add(add1(y_prev), add1(prev)) = add1(add(add1(y_prev), prev))
      ```

      By definition of `add` in the case of `add1`,
      the left hand side is equal to

      ``` cicada inactive
      add1(add(y_prev, add1(prev)))
      ```

      and the right hand side is equal to

      ``` cicada inactive
      add1(add1(add(y_prev, prev)))
      ```

      We can prove them equal by applying `add1` to inductive hypothesis

      ``` cicada inactive
           add(y_prev, add1(prev)) =       add1(add(y_prev, prev))
      add1(add(y_prev, add1(prev))) = add1(add1(add(y_prev, prev)))
      ```

  Since both Lemma 1 and Lemma 2 are proved,
  the inductive step of the original proof is finished.

**Q.E.D.**


## 3. Carrying out the plan

TODO

``` cicada
import {
  equal_map,
  equal_swap,
  equal_compose,
} from "../equality/01-equal-utilities.md"
```

``` cicada
function add_zero_commute(
  x: Nat
): Equal(Nat, add(Nat.zero, x), add(x, Nat.zero)) {
  return induction (x) {
    (x) => Equal(Nat, add(Nat.zero, x), add(x, Nat.zero))
    case zero => refl
    case add1(prev, almost) => equal_map(almost.prev, Nat.add1)
  }
}
```

``` cicada
function add_add1_commute(
  x: Nat, y: Nat,
): Equal(Nat, add(x, Nat.add1(y)), Nat.add1(add(x, y))) {
  return induction (x) {
    (x) => Equal(Nat, add(x, Nat.add1(y)), Nat.add1(add(x, y)))
    case zero => refl
    case add1(_prev, almost) => equal_map(almost.prev, Nat.add1)
  }
}
```

``` cicada
function add_commute(
  x: Nat, y: Nat,
): Equal(Nat, add(x, y), add(y, x)) {
  return induction (x) {
    (x) => Equal(Nat, add(x, y), add(y, x))
    // Base case
    case zero => add_zero_commute(y)
    // Induction step
    case add1(prev, almost) =>
      equal_compose(
        equal_map(almost.prev, Nat.add1),
        equal_swap(add_add1_commute(y, prev)),
      )
  }
}
```

## 4. Looking back

We import some example `Nat` to test our proof.

``` cicada
import { two, three } from "./01-nat.md"

add_commute(two, three)
add_commute(three, two)
```
