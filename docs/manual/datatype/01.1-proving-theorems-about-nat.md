---
section: Datatype
title: Proving Theorems About Nat
---

Before going to the next `datatype` -- `List`, let's prove some theorems about `Nat`,
to show off the power of dependent types!

How about the **commutative property of addition** for natural number?

It says,

> When doing addition for natural number,
> the order of the numbers can be changed without changing the answer.
>
> x + y = y + x

We import `Nat` and `add` from previous chapter first.

``` cicada
import { Nat, add } from "./01-nat.md"
```

Then we can express the following theorems by a type in our programming language,

> For all `x` and `y` in `Nat`, `add(x, y)` is equal to `add(y, x)`.

``` cicada
(x: Nat, y: Nat) -> Equal(Nat, add(x, y), add(y, x))
```

# Let's prove it!

To prove the theorem,
let's follow Pólya's advices about problem solving steps.

- Thanks, George Pólya (1887 – 1985),
  for your great teachings,
  and your lovely book "How to Solve It" (1945).

## 1. Understanding the problem

**What is the unknown?**

We need to prove a theorem in our programming language,
the theorem is expressed by a type, and to prove it
is to construct an element of that type.

> A theorem expressed by a type, is like a puzzle --
> a game between us and the type checker.
>
> If we can construct an element of that type, we win!

And we see the type is a `Pi`,
so its element will probably be a function.

The result type of the `Pi` is constructed by `Equal`,
we might need to use `Equal`'s constructors in our proof.

**What are the data?**

We have the definition of `Nat`, we already know a lot about it.

And we have the definition of `add`,
which tall us how the computation of addition is performed,
both in the case of `zero` and in the case of `add1`.

We also know something about the built-in type `Equal`,
but maybe we need to learn more about it.

## 2. Devising a plan

How should we prove the commutative property of addition,
in English mathematical prose?

Here is my plan, I want to review the proof in prose,
and try to translate it to our programming language.

> For all `x` and `y` in `Nat`, `add(x, y)` is equal to `add(y, x)`.

**Proof by mathematical induction over `x`.**

- **Base case.**

  Suppose `x` is `zero`.

  it is obvious that `zero + y = y + zero`,
  because the left hand side and the right hand side are both equal to `y`.

- **Inductive step.**

  Suppose `x` is `add1(prev)`.

  we have inductive hypothesis

  ``` cicada inactive
  add(prev, y) = add(y, prev)
  ```

  We need to prove

  ``` cicada inactive
  add(add1(prev), y) = add(y, add1(prev))
  ```

  If for the left hand side we have

  ``` cicada inactive
  add(add1(prev), y) = add1(add(prev, y)) // (Lemma 1)
  ```

  and for the right hand side we have

  ``` cicada inactive
  add(y, add1(prev)) = add1(add(y, prev)) // (Lemma 2)
  ```

  Then we can use inductive hypothesis to prove

  ``` cicada inactive
  add1(add(prev, y)) = add1(add(y, prev))
  ```

  by `add1` to the equation of inductive hypothesis

  ``` cicada inactive
  // inductive hypothesis:
  add(prev, y) = add(y, prev)
  // `add1` to both side:
  add1(add(prev, y)) = add1(add(y, prev))
  ```

  - **Proof of Lemma 1.**

    TODO

  - **Proof of Lemma 2.**

    TODO

**QED.**


## 3. Carrying out the plan

TODO

``` cicada
import {
  equal_map,
  equal_swap,
  equal_compose,
} from "../equality/01-equal-utilities.md"
```

``` cicada
function add_zero_commute(
  x: Nat
): Equal(Nat, add(Nat.zero, x), add(x, Nat.zero)) {
  return induction (x) {
    (x) => Equal(Nat, add(Nat.zero, x), add(x, Nat.zero))
    case zero => refl
    case add1(prev, almost) => equal_map(almost.prev, Nat.add1)
  }
}
```

``` cicada
function add_add1_commute(
  x: Nat, y: Nat,
): Equal(Nat, add(x, Nat.add1(y)), Nat.add1(add(x, y))) {
  return induction (x) {
    (x) => Equal(Nat, add(x, Nat.add1(y)), Nat.add1(add(x, y)))
    case zero => refl
    case add1(prev, almost) => equal_map(almost.prev, Nat.add1)
  }
}
```

``` cicada
function add_commute(
  x: Nat, y: Nat,
): Equal(Nat, add(x, y), add(y, x)) {
  return induction (x) {
    (x) => Equal(Nat, add(x, y), add(y, x))
    // Base case
    case zero => add_zero_commute(y)
    // Induction step
    case add1(prev, almost) =>
      equal_compose(
        equal_map(almost.prev, Nat.add1),
        equal_swap(add_add1_commute(y, prev)),
      )
  }
}
```

## 4. Looking back

We import some example `Nat` to test our proof.

``` cicada
import { two, three } from "./01-nat.md"

add_commute(two, three)
add_commute(three, two)
```
